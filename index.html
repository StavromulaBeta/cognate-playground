<html>
  <head>
    <meta charset="UTF-8">
    <link rel="stylesheet" href="https://unpkg.com/simpledotcss/simple.min.css">
    <style>
:root {
  --code: white;
  --bg: #212121;
  --accent-bg: #2b2b2b;
  --text: #dcdcdc;
  --text-light: #ababab;
  --accent: #ffb300;
  --accent-hover: #ffe099;
  --accent-text: var(--bg);
  --code: #f06292;
  --preformatted: #ccc;
  --disabled: #111;
}
    </style>
    <title>Cognate TS test</title>
  </head>

  <body>
    <header>
      <nav><a href="https://github.com/hedyhli/cognate-playground">Source</a></nav>
      <h4>Cognate Playground</h4>
    </header>
    <main>
      <div id="myapp">
        <textarea id="input" style="font-family: var(--mono-font); padding: .7rem 1rem; height: 10rem;"></textarea>
        <pre><p style="color: var(--text-light); margin-top: 0">Output:</p><code id="output" style="line-height: 1;"></code></pre>
        <pre><p style="color: var(--text-light); margin-top: 0">Stack:</p><code id="output-debug" style="line-height: 1;"></code></pre>
        <pre><p style="color: var(--text-light); margin-top: 0">Errors:</p><code id="output-error" style="line-height: 1;"></code></pre>
        <details><summary>Tree</summary>
          <pre><code id="output-tree" style="line-height: 1;"></code></pre>
        </details>
      </div>
    </main>
    <script src="tree-sitter.js"></script>
    <script type="module">
const $input = document.getElementById("input")
const $output = document.getElementById("output")
const $outputError = document.getElementById("output-error")
const $outputDebug = document.getElementById("output-debug")
const $outputTree = document.getElementById("output-tree")

await TreeSitter.init()
const parser = new TreeSitter();

const Cognate = await TreeSitter.Language.load('tree-sitter-cognate.wasm');
parser.setLanguage(Cognate);

////////

// Taken from lodash
function escape(string) {
  const htmlEscapes = {
      '&': '&amp;',
      '<': '&lt;',
      '>': '&gt;',
      '"': '&quot;',
      "'": '&#39;',
  };
  const reUnescapedHtml = /[&<>"']/g;
  const reHasUnescapedHtml = RegExp(reUnescapedHtml.source);

  return string && reHasUnescapedHtml.test(string)
        ? string.replace(reUnescapedHtml, (chr) => htmlEscapes[chr])
        : string || '';
}

function textLight(text) {
  return `<span style='color: var(--text-light)'>${text}</span>`;
}

function textMarked(text) {
  return `<span style='color: var(--marked)'>${text}</span>`;
}

const CONSTS = {
  True: true,
  False: false,
};

let Errors = [];

function appendError(message) {
  Errors.push(message);
}

function redrawErrors() {
  let html = textLight("None!");
  if (Errors.length != 0) {
    html = "<ol>";
    html += Errors.map((item) => `<li>${item}</li>`).join("");
    html += "</ol>";
  }
  $outputError.setHTMLUnsafe(html);
}

async function redraw() {
  const tree = parser.parse($input.value);
  Errors = [];
  draw_tree(tree);
  test(tree);
  redrawErrors();
}

// Return a string representation of a nested array.
function printArr(arr) {
  return arr.map((item) => (Array.isArray(item)) ? _printArr(item) : _repr(item)).join("\n")
}
function _repr(item) {
  switch (typeof item) {
    case 'object':
      return escape(item.name);
    case 'number':
      return item;
    case 'boolean':
      return textMarked(item ? 'True' : 'False');
    case 'string':
      return `"${escape(item)}"`;
    default:
      return textLight(`(repr unknown item ${textMarked(escape(item))})`);
  }
}
function _printArr(arr) {
  let output = "";

  const iter = (item, i) => {
    if (Array.isArray(item)) {
      output += "[";
      if (item.length > 0) {
        item.forEach(iter);
        output = output.slice(0, output.length-2);
      }
      output += "], ";
    } else {
      output += `${_repr(item)}, `;
    }
  };
  arr.forEach(iter);

  return `[${output.slice(0, output.length-2)}]`;
}

function test(tree) {
  const root = tree.rootNode;
  let output = "";

  function inner(node, stack) {
    let inStmt = false;
    let inBlock = false;

    let name;
    if (node.isMissing) {
      name = `MISSING ${node.type}`;
    } else if (node.isNamed) {
      name = node.type;
    } else {
      return;
    }

    if (name.endsWith("_comment")) {
      return;
    }

    if (name == "ERROR") {
      return;
    }

    // output += " -" + name + "\n"

    switch (name) {
      case "block":
        inBlock = true;
        stack.push([]);
        break;
      case "statement":
        inStmt = true;
        stack.push([]);
        break;
      case "number":
        stack.push(Number.parseFloat(node.text));
        break;
      case "string":
        // Strip quotes
        stack.push(node.text.slice(1, node.text.length-1));
        break;
      case "identifier":
        stack.push({ name: node.text });
        break;
    }

    if (inStmt || inBlock) {
      let pushto = stack[stack.length-1];
      node.children.forEach((child, c) => inner(child, pushto));

      if (inStmt) {
        let inside = stack[stack.length-1];
        stack.splice(stack.length-1, 1);
        inside = inside.reverse();
        inside.forEach((item) => stack.push(item));
      }
    } else {
      node.children.forEach((child, c) => inner(child, stack));
    }
    // output += `:: ${printArr(outstack)}\n`
  }

  let outstack = [];
  inner(root, outstack);

  let res = process(outstack, [], {...CONSTS});

  if (res.error != "") {
    appendError(res.error);
  }

  output += `${_printArr(res.stack)}\n`;
  $outputDebug.setHTMLUnsafe(output);

  output = res.output;
  $output.setHTMLUnsafe(output);
}

function process(stack, op, env) {
  let output = "";
  let error = "";

  function getVar(item) {
    if (item.name) {
      let value = env[item.name];
      if (value != undefined) {
        return value;
      } else {
        error = `unknown symbol ${textMarked(escape(item.name))}`;
        return undefined;
      }
    } else {
      return item;
    }
  }

  function resolve(item) {
    let value = getVar(item)
    switch (typeof value) {
      case 'object':
        if (Array.isArray(value)) {
          return 'block';
        }
        error = `unknown item ${textMarked(escape(value))}`;
        return undefined;
      case 'number':
        return value;
      case 'string':
        return escape(value);
      case 'boolean':
        return textMarked(value ? 'True' : 'False');
      case 'undefined':
        return undefined;
      default:
        error = `unknown item ${value}`;
        return undefined;
    }
  }

  function expectNumber(item) {
    let value = getVar(item);
    switch (typeof value) {
      case 'number':
        return value;
      case 'undefined':
        return undefined;
      default:
        error = `Expected number, got ${value}`;
        return undefined;
    }
  }

  for (let s = 0; s < stack.length; s++) {
    let item = stack[s];
    if (error != "") {
      break;
    }
    // output += `\nStack: ${op.map(_repr).join()}\nThis: ${_repr(item)}\n`
    switch (typeof item) {
      case 'object':
        if (!Array.isArray(item)) {
          let a, b;
          switch (item.name) {
            case 'Print':
              while (op.length > 0) {
                let str = resolve(op.pop());
                if (str) {
                  output += `${str} `;
                } else {
                  break;
                }
              }
              output += "\n"
              break;
            case 'Do':
              let do_result = process(op.pop(), op, env);
              if (do_result.error != "") {
                error = `at ${textMarked('Do')}: ${do_result.error}`;
                break;
              }
              op = do_result.stack;
              output += do_result.output;
              break;
            case 'Def':
              a = op.pop().name;
              b = op.pop();
              env[a] = { do: b };
              break;
            case '+':
              a = expectNumber(op.pop());
              if (a) {
                b = expectNumber(op.pop());
                if (b)
                  op.push(a + b);
              }
              break;
            case '-':
              a = expectNumber(op.pop());
              if (a) {
                b = expectNumber(op.pop());
                if (b)
                  op.push(b - a);
              }
              break;
            case '*':
              a = expectNumber(op.pop());
              if (a) {
                b = expectNumber(op.pop());
                if (b)
                  op.push(a * b);
              }
              break;
            case '/':
              a = expectNumber(op.pop());
              if (a) {
                b = expectNumber(op.pop());
                if (b)
                  op.push(b / a);
              }
              break;
            case 'Modulo':
              a = expectNumber(op.pop());
              if (a) {
                b = expectNumber(op.pop());
                if (b)
                  op.push(b % a);
              }
              break;
            case '==':
              a = getVar(op.pop());
              if (a == undefined)
                break;
              b = getVar(op.pop());
              if (b == undefined)
                break;
              if (typeof a == 'number' && typeof b == 'number') {
                op.push(a == b);
              } else {
                error = "'==' only supports comparison of number and number"
              }
              break;
            case 'Not':
              a = getVar(op.pop());
              if (a == undefined)
                break;
              if (typeof a == 'boolean') {
                op.push(!a);
              } else {
                error = `${textMarked('Not')} only supports boolean`
              }
              break;
            case 'If':
              let cond = getVar(op.pop());
              if (cond == undefined)
                break;
              let then = getVar(op.pop());
              if (then == undefined)
                break;
              let fallback = getVar(op.pop());
              if (fallback == undefined)
                break;
              if (typeof cond == 'boolean') {
                op.push(cond ? then : fallback);
              } else {
                error = `If condition must evaluate to a boolean, got ${cond}`;
              }
              break;
            case 'Twin':
              a = op.pop();
              op.push(a);
              op.push(a);
              break;
            case 'Let':
              a = op.pop().name;
              b = op.pop();
              env[a] = b;
              break;
            default:
              if (env[item.name] && env[item.name].do) {
                // Defined, and is a function.
                let call_result = process(env[item.name].do, op, env);
                if (call_result.error != "") {
                  error = `in function call of ${textMarked(item.name)}: ` + call_result.error;
                  break;
                }
                op = call_result.stack;
                output += call_result.output;
              } else {
                op.push(item);
              }
              break;
          };
        } else {
          op.push(item);
        }
        break;
      default:
        op.push(item);
        break;
    };
  }

  return {output: output, stack: op, error: error};
}

function walk(tree) {
  const cursor = tree.walk();
  let output = "";
  let indent = 0;
  let visitedChildren = false;

  while (true) {
    // Name
    let name;
    if (cursor.nodeIsMissing) {
      name = `MISSING ${cursor.nodeType}`;
    } else if (cursor.nodeIsNamed) {
      name = cursor.nodeType;
    }

    if (!visitedChildren) {
      // Output
      if (name) {
        output += `${'  '.repeat(indent)}${name}\n`
      }

      // Visit children
      if (cursor.gotoFirstChild()) {
        indent++;
      } else {
        visitedChildren = true;
      }
    } else {
      // Visit next node
      if (cursor.gotoNextSibling()) {
        visitedChildren = false;
      } else if (cursor.gotoParent()) {
        indent--;
        visitedChildren = true;
      } else {
        // Nothing else to visit
        break;
      }
    }
  }
  
  cursor.delete();

  $output.setHTMLUnsafe(output);
}

function draw_tree(tree) {
  const cursor = tree.walk();

  let row = '';
  const rows = [];
  let finishedRow = false;
  let visitedChildren = false;
  let indentLevel = 0;

  for (let i = 0;; i++) {
    let displayName;
    let nameColor = "var(--text)";

    if (cursor.nodeIsMissing) {
      displayName = `MISSING ${cursor.nodeType}`;
      nameColor = "var(--marked)";
    } else if (cursor.nodeIsNamed) {
      displayName = cursor.nodeType;
    }

    if (displayName == "ERROR") {
      nameColor = "var(--marked)";
    }

    if (visitedChildren) {
      if (displayName) {
        finishedRow = true;
      }

      let prev_type = cursor.nodeType;
      let prev_text = cursor.nodeText;
      let prev_start = cursor.startPosition;

      if (cursor.gotoNextSibling()) {
        visitedChildren = false;
      } else if (cursor.gotoParent()) {
        visitedChildren = true;
        indentLevel--;

        if (prev_type == "ERROR" && cursor.nodeType == "ERROR") {
          Errors.push(`unexpected token: ${textMarked(prev_text)} ` + textLight(`(${prev_start.row}, ${prev_start.column})`));
        }
      } else {
        // No parent and no sibling
        break;
      }
    } else {
      if (displayName) {
        if (finishedRow) {
          row += '</div>';
          rows.push(row);
          finishedRow = false;
        }
        const start = cursor.startPosition;
        const end = cursor.endPosition;
        const id = cursor.nodeId;
        let fieldName = cursor.currentFieldName;
        if (fieldName) {
          fieldName = `<span style="color: lightskyblue;">${fieldName}</span>: `;
        } else {
          fieldName = '';
        }
        const parenLeft = textLight("(")
        const parenRight = textLight(")")
        row = `<div style='margin: 0 0'>${'  '.repeat(indentLevel)}${fieldName}${parenLeft}<span style='color: ${nameColor}' data-id=${id} data-range="${start.row},${start.column},${end.row},${end.column}">${displayName}</span>${parenRight}`;
        finishedRow = true;

        if (cursor.nodeIsMissing) {
          Errors.push(`missing: ${textMarked(cursor.nodeType)} ` + textLight(`(${start.row}, ${start.column})`))
        }
      }

      if (cursor.gotoFirstChild()) {
        visitedChildren = false;
        indentLevel++;
      } else {
        visitedChildren = true;
      }
    }
  }
  if (finishedRow) {
    row += '</div>';
    rows.push(row);
  }

  cursor.delete();

  $outputTree.setHTMLUnsafe(rows.join("\n"));
}

//////////

$input.addEventListener("input", async function (event) {
  await redraw();
});

redraw();
    </script>
    <footer><p>Footer</p></footer>
  </body>
</html>
