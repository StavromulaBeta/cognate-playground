<html>
  <head>
    <meta charset="UTF-8">
    <link rel="stylesheet" href="https://unpkg.com/simpledotcss/simple.min.css">
    <style>
    :root {
      --code: white;
      --bg: #212121;
      --accent-bg: #2b2b2b;
      --text: #dcdcdc;
      --text-light: #ababab;
      --accent: #ffb300;
      --accent-hover: #ffe099;
      --accent-text: var(--bg);
      --code: #f06292;
      --preformatted: #ccc;
      --disabled: #111;
    }
    body {
      grid-template-columns: 1fr min(65rem,95%) 1fr;
      font-size: 1rem;
    }
    </style>
    <title>Cognate Playground</title>
  </head>

  <body>
    <header>
      <nav>
        <a href="https://github.com/hedyhli/cognate-playground">Source</a>
        <a href="https://github.com/cognate-lang/cognate">Cognate</a>
        <a href="https://cognate-lang.github.io/learn.html">Tutorial</a>
      </nav>
      <h4>Cognate Playground</h4>
      <small>A fully client-side interactive playground for the Cognate programming language.</small>
    </header>
    <main>
      <style>
      .container select {
        width: 100%;
      }

      .container textarea {
        min-height: 22rem;
        font-family: var(--mono-font);
        padding: .7rem 1rem;
        resize: none;
        margin-bottom: 0;
        resize: vertical;
      }

      .container div {
        overflow-x: auto;
      }

      .container pre p {
        color: var(--text-light);
        margin-top: 0;
      }

      pre code {
        line-height: 1;
      }

      @media (min-width: 800px) {
        .container {
          height: 40rem;
          display: grid;
          justify-items: stretch;
          align-items: stretch;
          justify-content: stretch;
          align-content: stretch;
          grid-template-areas:
            "input output"
            "input output"
            "input output"
            "input output"
            "input output"
            "input stack"
            "input stack"
            "input errors"
            "input errors"
            "select errors";
          grid-template-columns: repeat(2, 1fr);
          grid-template-rows: repeat(10, 1fr);
          row-gap: .5rem;
          column-gap: .5rem;
        }

        .container pre, .container select, .container textarea {
          margin-top: 0;
          margin-bottom: 0;
          height: 100%;
        }

        .container textarea {
          resize: none;
        }

        .container div {
          height: 100%;
          align-self: stretch;
          justify-self: stretch;
        }
      }
      </style>
      <div class="container">
        <div style="grid-area: select;">
          <select id="select-example" name="example">
            <option value="custom" selected>Custom</option>
            <option value="hanoi">Hanoi</option>
            <option value="math">Math</option>
            <option value="stack">Stack</option>
          </select>
        </div>
        <div style="grid-area: input">
          <textarea id="input" placeholder="Print &quot;Hello, World!&quot;"></textarea>
        </div>
        <div style="grid-area: output">
          <pre><p>Output:</p><code id="output"></code></pre>
        </div>
        <div style="grid-area: stack">
          <pre><p>Stack:</p><code id="output-debug"></code></pre>
        </div>
        <div style="grid-area: errors">
          <pre><p>Errors:</p><code id="output-error"></code></pre>
        </div>
      </div>
      <div style="margin-top: 1rem;">
        <details><summary>Tree</summary>
          <pre><code id="output-tree"></code></pre>
        </details>
      </div>
    </main>
    <script src="tree-sitter.js"></script>
    <script type="module">
const $input = document.getElementById("input")
const $selectExample = document.getElementById("select-example")
const $output = document.getElementById("output")
const $outputError = document.getElementById("output-error")
const $outputDebug = document.getElementById("output-debug")
const $outputTree = document.getElementById("output-tree")

const STORAGE_KEY = "cognate-playground";
const Store = {
  getInput: () => JSON.parse(localStorage.getItem(STORAGE_KEY) || '{}').custom || 'Print "Hello, world!"',
  saveInput: (newInput) => localStorage.setItem(STORAGE_KEY, JSON.stringify({ custom: newInput })),
};

$input.value = Store.getInput();
$selectExample.value = "custom";

await TreeSitter.init()
const parser = new TreeSitter();

const Cognate = await TreeSitter.Language.load('tree-sitter-cognate.wasm');
parser.setLanguage(Cognate);

let Prelude = '';
// TODO: Error message on failure.

fetch("prelude.cog")
  .then((res) => res.text())
  .then((text) => {
    Prelude = text;
    redraw();
  })
  .catch((e) => console.error(e));

const ExamplePresets = {
  custom: `Print "custom here"`,
  hanoi: `Def Move discs as (
   Let N be the number of discs;
   Let A be the first rod;
   Let B be the second rod;
   Let C be the third rod;

   Unless Zero? N (
      Move - 1 N discs from A via C to B;
      Print "disc" N ":" A "-->" C;
      Move - 1 N discs from B via A to C;
   )
);

show steps to Move 3 discs from \\X via \\Y to \\Z;`,
  math: `Print - 3 5;
Print > 10 11;
Print == 2 Modulo 3 20;`,
  stack: `Print Twin 0;
Print Twin Twin 0;
Print Drop 1 2 3 4 5;
Print * Twin 4;
Print * * Triplet 4;`,
};

////////

// Taken from lodash
function escape(string) {
  const htmlEscapes = {
      '&': '&amp;',
      '<': '&lt;',
      '>': '&gt;',
      '"': '&quot;',
      "'": '&#39;',
  };
  const reUnescapedHtml = /[&<>"']/g;
  const reHasUnescapedHtml = RegExp(reUnescapedHtml.source);

  return string && reHasUnescapedHtml.test(string)
        ? string.replace(reUnescapedHtml, (chr) => htmlEscapes[chr])
        : string || '';
}

function textLight(text) {
  return `<span style='color: var(--text-light)'>${text}</span>`;
}

function textMarked(text) {
  return `<span style='color: var(--marked)'>${text}</span>`;
}

function normalizeIdentifier(name) {
  return name[0].toUpperCase() + name.substr(1).toLowerCase();
}

const token2object = {
  number: token => ({ type: 'number', value: Number.parseFloat(token) }),
  string: token => ({ type: 'string', value: token.slice(1, token.length-1) }),
  boolean: token => ({ type: 'boolean', value: (token == 'True') }),
  identifier: token => ({ type: 'identifier', value: normalizeIdentifier(token) }),
  symbol: token => ({ type: 'symbol', value: token.slice(1).toLowerCase() }),
  block: body => ({ type: 'block', body: body, env: {} }),
};

const value2object = {
  number: value => ({ type: 'number', value: value }),
  string: value => ({ type: 'string', value: value }),
  boolean: value => ({ type: 'boolean', value: value ? true : false }),
  // Is this ever needed?
  identifier: value => ({ type: 'identifier', value: normalizeIdentifier(value) }),
  // And this.
  symbol: value => ({ type: 'symbol', value: value }),
  function: block => ({ type: 'function', body: block.body, env: block.env }),
};

let Errors = [];

function appendError(message) {
  Errors.push(message);
}

function redrawErrors() {
  let html = textLight("None!");
  if (Errors.length != 0) {
    html = "<ol>";
    html += Errors.map((item) => `<li>${item}</li>`).join("");
    html += "</ol>";
  }
  $outputError.innerHTML = html;
}

function redraw() {
  const env = {};
  let result;

  const preludeTree = parser.parse(Prelude);
  Errors = [];
  result = parse(preludeTree, env);
  if (Errors.length > 0) {
    redrawErrors();
    $outputDebug.innerHTML = result.debug;
    $outputError.innerHTML = "<p>Parsing of prelude failed!</p>" + $outputError.innerHTML;
    return;
  }
  console.log("--------");

  Errors = [];
  const tree = parser.parse($input.value);
  draw_tree(tree);
  result = parse(tree, env);
  $outputDebug.innerHTML = result.debug;
  $output.innerHTML = result.output;
  redrawErrors();
}

// Return a string representation of a nested array.
function printArr(arr) {
  return arr.map((item) => (item.type == 'block') ? _printArr(item.body) : _repr(item)).join("\n");
}

function _repr(item) {
  switch (item.type) {
    case 'identifier':
      return escape(item.value);
    case 'number':
      return item.value;
    case 'boolean':
      return textMarked(item.value ? 'True' : 'False');
    case 'string':
      return `"${escape(item.value)}"`;
    case 'symbol':
      return `\\${escape(item.value)}`;
    default:
      return textLight(`(unknown item of type ${textMarked(escape(item.type))})`);
  }
}

function _printArr(arr) {
  let output = "";

  const iter = (item, i) => {
    if (item.type == 'block') {
      output += "[";
      if (item.body.length > 0) {
        item.body.forEach(iter);
        output = output.slice(0, output.length-2);
      }
      output += "], ";
    } else {
      output += `${_repr(item)}, `;
    }
  };
  arr.forEach(iter);

  return `[${output.slice(0, output.length-2)}]`;
}

function parse(tree, env) {
  const root = tree.rootNode;
  let output = "";
  let bail = false;

  function inner(node, stack) {
    let inStmt = false;
    let inBlock = false;

    let name;
    if (node.isMissing) {
      name = `MISSING ${node.type}`;
    } else if (node.isNamed) {
      name = node.type;
    } else {
      return;
    }

    if (name.endsWith("_comment")) {
      return;
    }

    if (name == "ERROR") {
      return;
    }

    // output += " -" + name + "\n"

    switch (name) {
      case "block":
        inBlock = true;
        stack.push(token2object.block([]));
        break;
      case "statement":
        inStmt = true;
        stack.push([]);
        break;
      case "number":
      case "string":
      case "boolean":
      case "symbol":
      case "identifier":
        stack.push(token2object[name](node.text));
        break;
      case "source_file":
        break;
      default:
        if (!name.startsWith("MISSING")) {
          appendError(`INTERNAL ERROR: unknown token type ${textMarked(name)} from tree-sitter!`);
          bail = true;
          return;
        }
    }

    if (inStmt) {
      let pushto = stack[stack.length-1];
      node.children.forEach((child, c) => inner(child, pushto));

      let inside = stack[stack.length-1];
      stack.splice(stack.length-1, 1);
      inside = inside.reverse();

      for(let i = 0; i < inside.length; i ++) {
        let item = inside[i];
        let previous = inside[i-1];
        if (item.type == 'identifier' && ['Def', 'Let', 'Set'].includes(item.value)) {
          if (!(previous && previous.type == 'identifier')) {
            let error = `syntax error: ${textMarked(item.value)} must follow an identifier`;
            if (previous)
              error += `, got ${previous.type}`;
            appendError(error);
            bail = true;
            return;
          }
        }
        stack.push(item)
      }

    } else if (inBlock) {
      let pushto = stack[stack.length-1].body;
      node.children.forEach((child, c) => inner(child, pushto));

    } else {
      node.children.forEach((child, c) => inner(child, stack));
    }
    // output += `:: ${printArr(outstack)}\n`
  }

  let outstack = [];
  inner(root, outstack);

  if (bail) {
    return { debug: output, output: '' };
  }

  let res = process(outstack, [], env);

  if (res.error != "") {
    appendError(res.error);
  }

  output += `${_printArr(res.stack)}\n`;

  return { debug: output, output: res.output }
}

function process(stack, op, initEnv, scoped) {
  let env = scoped ? {...initEnv} : initEnv;
  let updates = {};

  // Variables defined in this block;
  // [name: string]: bool
  // TODO: Is this necessary when we have both `initEnv` and `env`?
  let newDefs = {};

  let output = "";
  let error = "";

  function getVar(item) {
    if (item.type == 'identifier') {
      let value = env[item.value];
      if (value != undefined) {
        return value;
      } else {
        error = `undefined symbol ${textMarked(escape(item.value))}`;
        return undefined;
      }
    } else {
      return item;
    }
  }

  function resolve(item) {
    if (item == undefined) {
      return undefined;
    }

    switch (item.type) {
      case 'block':
        return textMarked('(block)');
      case 'number':
        return item.value;
      case 'string':
        return escape(item.value);
      case 'symbol':
        return escape(item.value);
      case 'boolean':
        return textMarked(item.value ? 'True' : 'False');
      default:
        error = `unknown item of type ${textMarked(escape(item.type))}, value ${textMarked(escape(item))}`;
        return undefined;
    }
  }

  function exists(item, kind) {
    if (item == undefined) {
      error = `expected ${kind}`;
      return undefined;
    }
    return item;
  }

  function expect(item, type) {
    if (item == undefined) {
      return undefined;
    }
    if (item.type == type) {
      return item;
    }
    error = `expected ${type}, got ${item.type}`;
    return undefined;
  }

  for (let s = 0; s < stack.length; s++) {
    let item = stack[s];
    // console.log(item.value || item, _printArr(op));
    let next = stack[s+1];
    if (error != "") {
      break;
    }
    switch (item.type) {
      case 'block': {
        item.env = {...env};
        op.push(item);
        break;
      }
      case 'identifier':
        if (next != undefined && next.type == 'identifier') {
          if (next.value == 'Def' || next.value == 'Let' || next.value == 'Set') {
            op.push(item);
            continue;
          }
        }
        if (env[item.value] && env[item.value].type == 'function') {
          // Defined, and is a function.
          let call_result = process(env[item.value].body, op, env[item.value].env, true);
          if (call_result.error != "") {
            error = `in ${textMarked(item.value)}: ` + call_result.error;
            break;
          }
          // // Update variables from 'Set' calls.
          // let keys = Object.keys(call_result.updates);
          // for (let k = 0; k < keys.length; k++) {
          //   let name = keys[k];
          //   if (env[name] != undefined) {
          //     env[name] = call_result.updates[name];
          //   }
          // }
          // updates = {...updates, ...call_result.updates};
          op = call_result.stack;
          output += call_result.output;
          continue;
        }
        switch (item.value) {
          case 'Def': {
            // This check is technically done already during parsing.
            let a = expect(exists(op.pop(), `identifier`), 'identifier');
            if (a == undefined) {
              error = `in ${textMarked('Def')}: ` + error;
              break;
            }
            let b = expect(exists(op.pop(), `function body`), 'block');
            if (b == undefined) {
              error = `in ${textMarked('Def')}: ` + error;
              break;
            }
            // if (env[a.value] != undefined && newDefs[a.value]) {
            //   error = `in ${textMarked('Def')}: cannot shadow in the same block`;
            //   break;
            // }
            newDefs[a.value] = true;
            env[a.value] = value2object.function(b);
            // Include current declaration in block
            env[a.value].env[a.value] = env[a.value];
            break;
          }
          case 'Print': {
            while (op.length > 0) {
              let str = resolve(op.pop());
              if (str != undefined) {
                output += `${str} `;
              } else {
                break;
              }
            }
            output += "\n"
            break;
          }
          case 'Do': {
            // Blocks create a new scope.
            let block = expect(exists(op.pop(), 'block'), 'block');
            // TODO: Ok to not spread env here?
            let do_result = process(block.body, op, block.env, true);
            if (do_result.error != "") {
              error = `in ${textMarked('Do')}: ${do_result.error}`;
              break;
            }
            // // Update variables from 'Set' calls.
            // let keys = Object.keys(do_result.updates);
            // for (let k = 0; k < keys.length; k++) {
            //   let name = keys[k];
            //   if (env[name] != undefined) {
            //     env[name] = do_result.updates[name];
            //   }
            // }
            // updates = {...updates, ...do_result.updates};
            op = do_result.stack;
            output += do_result.output;
            break;
          }
          case '+': {
            let a = expect(exists(op.pop(), 'operand'), 'number');
            let b;
            if (a != undefined) {
              b = expect(exists(op.pop(), 'operand'), 'number');
              if (b != undefined)
                op.push(value2object.number(a.value + b.value));
            }
            break;
          }
          case '-': {
            let a = expect(exists(op.pop(), 'operand'), 'number');
            let b;
            if (a) {
              b = expect(exists(op.pop(), 'operand'), 'number');
              if (b)
                op.push(value2object.number(b.value - a.value));
            }
            break;
          }
          case '*': {
            let a = expect(exists(op.pop(), 'operand'), 'number');
            let b;
            if (a) {
              b = expect(exists(op.pop(), 'operand'), 'number');
              if (b)
                op.push(value2object.number(a.value * b.value));
            }
            break;
          }
          case '/': {
            let a = expect(exists(op.pop(), 'operand'), 'number');
            let b;
            if (a) {
              b = expect(exists(op.pop(), 'operand'), 'number');
              if (b)
                op.push(value2object.number(b.value / a.value));
            }
            break;
          }
          case 'Modulo': {
            let a = expect(exists(op.pop(), 'operand'), 'number');
            let b;
            if (a) {
              b = expect(exists(op.pop(), 'operand'), 'number');
              if (b)
                op.push(value2object.number(b.value % a.value));
            }
            break;
          }
          case '==': {
            let a = expect(exists(op.pop(), 'operand'), 'number');
            let b;
            if (a == undefined)
              break;
            b = expect(exists(op.pop(), 'operand'), 'number');
            if (b == undefined)
              break;
            op.push(value2object.boolean(a.value == b.value));
            break;
          }
          case '!=': {
            let a = expect(exists(op.pop(), 'operand'), 'number');
            if (a == undefined)
              break;
            let b = expect(exists(op.pop(), 'operand'), 'number');
            if (b == undefined)
              break;
            op.push(value2object.boolean(a.value != b.value));
            break;
          }
          case '>': {
            let a = expect(exists(op.pop(), 'operand'), 'number');
            if (a == undefined)
              break;
            let b = expect(exists(op.pop(), 'operand'), 'number');
            if (b == undefined)
              break;
            op.push(value2object.boolean(b.value > a.value));
            break;
          }
          case '<': {
            let a = expect(exists(op.pop(), 'operand'), 'number');
            if (a == undefined)
              break;
            let b = expect(exists(op.pop(), 'operand'), 'number');
            if (b == undefined)
              break;
            op.push(value2object.boolean(b.value < a.value));
            break;
          }
          case '>=': {
            let a = expect(exists(op.pop(), 'operand'), 'number');
            if (a == undefined)
              break;
            let b = expect(exists(op.pop(), 'operand'), 'number');
            if (b == undefined)
              break;
            op.push(value2object.boolean(b.value >= a.value));
            break;
          }
          case '<=': {
            let a = expect(exists(op.pop(), 'operand'), 'number');
            if (a == undefined)
              break;
            let b = expect(exists(op.pop(), 'operand'), 'number');
            if (b == undefined)
              break;
            op.push(value2object.boolean(b.value <= a.value));
            break;
          }
          case 'Number?': {
            let a = exists(op.pop(), 'boolean operand');
            if (a != undefined)
              op.push(value2object.boolean(a.type == 'number'));
            break;
          }
          case 'Zero?': {
            let a = expect(exists(op.pop(), 'operand'), 'number');
            if (a != undefined)
              op.push(value2object.boolean(a.value == 0));
            break;
          }
          case 'Number!':
          case 'String!':
          case 'Block!':
          case 'Boolean!': {
            let a = exists(op[op.length-1], 'operand');
            let type = item.value.slice(0, item.value.length-1).toLowerCase();
            if (a != undefined && a.type != type)
              error = `${type} assertion failed`
            break;
          }
          case 'Integer!': {
            let a = exists(op[op.length-1], 'operand');
            if (a != undefined && !(a.type == 'number' && Number.isInteger(a.value)))
              error = "integer assertion failed"
            break;
          }
          case 'Not': {
            let a = expect(exists(op.pop(), 'boolean operand'), 'boolean');
            if (a != undefined)
              op.push(value2object.boolean(!a.value));
            break;
          }
          case 'And': {
            let a = expect(exists(op.pop(), 'boolean operand'), 'boolean');
            if (a == undefined)
              break
            let b = expect(exists(op.pop(), 'boolean operand'), 'boolean');
            if (b == undefined)
              break
            op.push(value2object.boolean(a.value && b.value));
            break;
          }
          case 'Or': {
            let a = expect(exists(op.pop(), 'boolean operand'), 'boolean');
            if (a == undefined)
              break
            let b = expect(exists(op.pop(), 'boolean operand'), 'boolean');
            if (b == undefined)
              break
            op.push(value2object.boolean(a.value || b.value));
            break;
          }
          case 'Xor': {
            let a = expect(exists(op.pop(), 'boolean operand'), 'boolean');
            if (a == undefined)
              break
            let b = expect(exists(op.pop(), 'boolean operand'), 'boolean');
            if (b == undefined)
              break
            op.push(value2object.boolean(a.value != b.value));
            break;
          }
          case 'If': {
            let cond = expect(exists(op.pop(), "condition"), 'boolean');
            if (cond == undefined)
              break;
            let then = exists(op.pop(), "'then' clause");
            if (then == undefined)
              break;
            let fallback = exists(op.pop(), "'else' clause");
            if (fallback == undefined)
              break;
            op.push(cond.value ? then : fallback);
            break;
          }
          case 'Let': {
            let a = expect(exists(op.pop(), 'identifier'), 'identifier');
            if (a == undefined) {
              error = `in ${textMarked('Let')}: ` + error;
              break;
            }
            let b = op.pop();
            if (b == undefined) {
              error = `in ${textMarked('Let')}: expected value to set`;
              break;
            }
            if (env[a.value] != undefined && newDefs[a.value]) {
              error = `in ${textMarked('Let')}: cannot shadow in the same block`;
              break;
            }
            env[a.value] = b;
            newDefs[a.value] = true;
            break;
          }
          case 'Set': {
            // let a = expect(exists(op.pop(), 'identifier'), 'identifier');
            // if (a == undefined)
            //   break;
            // let b = op.pop();
            // if (b == undefined) {
            //   error = `in ${textMarked('Set')}: value expected`;
            //   break;
            // }
            // if (getVar(a) == undefined) {
            //   error = `attempt to set undefined variable ${textMarked(name)}`;
            // } else {
            //   updates[a.value] = b;
            //   env[a.value] = b;
            // }
            break;
          }
          default: {
            let a = getVar(item);
            if (a != undefined) {
              op.push(a);
            }
            break;
          }
        };
        break;
      default:
        op.push(item);
        break;
    };
  }

  return {output: output, stack: op, error: error, updates: updates};
}

function draw_tree(tree) {
  const cursor = tree.walk();

  let row = '';
  const rows = [];
  let finishedRow = false;
  let visitedChildren = false;
  let indentLevel = 0;

  for (let i = 0;; i++) {
    let displayName;
    let nameColor = "var(--text)";

    if (cursor.nodeIsMissing) {
      displayName = `MISSING ${cursor.nodeType}`;
      nameColor = "var(--marked)";
    } else if (cursor.nodeIsNamed) {
      displayName = cursor.nodeType;
    }

    if (displayName == "ERROR") {
      nameColor = "var(--marked)";
    }

    if (visitedChildren) {
      if (displayName) {
        finishedRow = true;
      }

      let prev_type = cursor.nodeType;
      let prev_text = cursor.nodeText;
      let prev_start = cursor.startPosition;

      if (cursor.gotoNextSibling()) {
        visitedChildren = false;
      } else if (cursor.gotoParent()) {
        visitedChildren = true;
        indentLevel--;

        if (prev_type == "ERROR" && cursor.nodeType == "ERROR") {
          Errors.push(`unexpected token: ${textMarked(prev_text)} ` + textLight(`(${prev_start.row}, ${prev_start.column})`));
        }
      } else {
        // No parent and no sibling
        break;
      }
    } else {
      if (displayName) {
        if (finishedRow) {
          row += '</div>';
          rows.push(row);
          finishedRow = false;
        }
        const start = cursor.startPosition;
        const end = cursor.endPosition;
        const id = cursor.nodeId;
        let fieldName = cursor.currentFieldName;
        if (fieldName) {
          fieldName = `<span style="color: lightskyblue;">${fieldName}</span>: `;
        } else {
          fieldName = '';
        }
        const parenLeft = textLight("(")
        const parenRight = textLight(")")
        row = `<div style='margin: 0 0'>${'  '.repeat(indentLevel)}${fieldName}${parenLeft}<span style='color: ${nameColor}' data-id=${id} data-range="${start.row},${start.column},${end.row},${end.column}">${displayName}</span>${parenRight}`;
        finishedRow = true;

        if (cursor.nodeIsMissing) {
          Errors.push(`missing: ${textMarked(cursor.nodeType)} ` + textLight(`(${start.row}, ${start.column})`))
        }
      }

      if (cursor.gotoFirstChild()) {
        visitedChildren = false;
        indentLevel++;
      } else {
        visitedChildren = true;
      }
    }
  }
  if (finishedRow) {
    row += '</div>';
    rows.push(row);
  }

  cursor.delete();

  $outputTree.innerHTML = rows.join("\n");
}

//////////

$input.addEventListener("input", function (event) {
  Store.saveInput($input.value);
  redraw();
});

$selectExample.addEventListener("change", function () {
  let key = $selectExample.value;
  $input.value = key == "custom" ? Store.getInput() : ExamplePresets[key];
  redraw();
});

redraw();
    </script>
    <footer><p>This project is work in progress. Kindly report any issues to <a href="https://github.com/hedyhli/cognate-playground/issues">the GitHub repo</a>, and when in doubt, always verify with the official Cognate compiler.</p></footer>
  </body>
</html>
